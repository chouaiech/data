package io.piveau.metrics.reporter.pdf;

import org.apache.pdfbox.pdmodel.font.PDFont;
import org.jsoup.nodes.Element;
import org.jsoup.nodes.Node;
import org.jsoup.nodes.TextNode;
import org.jsoup.select.NodeVisitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import rst.pdfbox.layout.elements.Paragraph;
import rst.pdfbox.layout.text.*;
import rst.pdfbox.layout.text.annotations.AnnotatedStyledText;
import rst.pdfbox.layout.text.annotations.Annotations.HyperlinkAnnotation;
import rst.pdfbox.layout.text.annotations.Annotations.HyperlinkAnnotation.LinkStyle;
import rst.pdfbox.layout.text.annotations.Annotations.UnderlineAnnotation;
import rst.pdfbox.layout.util.CompatibilityHelper;

import java.awt.*;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

// Features to be implemented if required:
// Nested lists
// More flexible mechanism to support more advanced structures (e.g. lists within <a> tag).

public class GenerateParagraphJSoupNodeVisitor implements NodeVisitor {

    private static final Logger log = LoggerFactory.getLogger(GenerateParagraphJSoupNodeVisitor.class);

    // These nodes are generated by JSoup during the parsing process in order to produce a valid HTML document.
    // The warning regarding unsupported tags ignores these elements.
    public static final List<String> JSOUP_CREATED_ELEMENTS = List.of("#root", "html", "head", "body");

    private final Paragraph paragraph;
    private final Styles styles;

    private PDFont currentFont;
    private float currentFontSize;

    private boolean skipNextTextNode;
    private boolean underline;
    private boolean removeLeadingSpaceInNextTextNode;

    private IOException exception;

    public GenerateParagraphJSoupNodeVisitor(Paragraph paragraph, Styles styles) {
        this.paragraph = paragraph;
        this.styles = styles;
        this.skipNextTextNode = false;
        this.underline = false;
        this.removeLeadingSpaceInNextTextNode = true;
        this.currentFontSize = styles.getParagraphStyle().getFontSize();
        this.currentFont = styles.getParagraphStyle().getFont();
    }

    public Paragraph getParagraph() throws IOException {
        // it is not possible to forward thrown IOException using the overridden visitor methods
        // if more than one Exceptions are thrown, an IOException with the last message is thrown at this point
        if (exception != null) {
            throw exception;
        } else {
            return paragraph;
        }
    }

    @Override
    public void head(Node node, int depth) {
        try {
            if (node instanceof Element) {
                Element elementNode = (Element) node;

                switch (elementNode.normalName()) {
                    case "p":
                        currentFontSize = styles.getParagraphStyle().getFontSize();
                        currentFont = styles.getParagraphStyle().getFont();
                        removeLeadingSpaceInNextTextNode = true;
                        paragraph.add(new NewLine(new FontDescriptor(currentFont, currentFontSize)));
                        break;

                    case "br":
                        paragraph.add(new NewLine(new FontDescriptor(currentFont, currentFontSize)));
                        removeLeadingSpaceInNextTextNode = true;
                        break;

                    case "h6":
                        currentFontSize = styles.getParagraphStyle().getFontSize();
                        currentFont = styles.getParagraphStyle().getFont();
                        paragraph.add(new NewLine(new FontDescriptor(currentFont, currentFontSize)));
                        removeLeadingSpaceInNextTextNode = true;
                        underline = true;
                        break;

                    case "a":
                        if (elementNode.hasText()) {
                            StringBuilder text = new StringBuilder();
                            for (TextNode textNode : elementNode.textNodes()) {
                                text.append(textNode.text());
                            }
                            String href = elementNode.absUrl("href");
                            UnderlineAnnotation underlineAnnotation = new UnderlineAnnotation(-0.1f, 1f);
                            HyperlinkAnnotation hyperlink = new HyperlinkAnnotation(href, LinkStyle.none);
                            AnnotatedStyledText styledText = new AnnotatedStyledText(text.toString(), currentFontSize, currentFont,
                                    Color.blue, 0, Arrays.asList(underlineAnnotation, hyperlink));

                            paragraph.add(styledText);
                            skipNextTextNode = true;
                        }
                        break;

                    case "li":
                        paragraph.add(new NewLine(new FontDescriptor(currentFont, currentFontSize)));
                        paragraph.add(new Indent(
                                CompatibilityHelper.getBulletCharacter(1) + "  ",
                                4,
                                SpaceUnit.em,
                                currentFontSize,
                                currentFont,
                                Alignment.Right));
                        removeLeadingSpaceInNextTextNode = true;
                        break;

                    case "strong":
                        currentFontSize = styles.getBoldParagraphStyle().getFontSize();
                        currentFont = styles.getBoldParagraphStyle().getFont();
                        break;

                    // explicitly ignore entering <ul> and <i>
                    case "ul":
                    case "i":
                        break;

                    default:
                        if (!JSOUP_CREATED_ELEMENTS.contains(elementNode.normalName())) {
                            log.warn("HTML Tag not supported: <{}>", elementNode.normalName());
                        }
                        break;
                }
            } else if (node instanceof TextNode && !skipNextTextNode) {
                TextNode textNode = (TextNode) node;

                if (removeLeadingSpaceInNextTextNode) {
                    // The Node is manipulated deliberately
                    textNode.text(textNode.text().stripLeading());
                    removeLeadingSpaceInNextTextNode = false;
                }

                if (underline) {
                    UnderlineAnnotation underlineAnnotation = new UnderlineAnnotation(-0.1f, 1f);
                    AnnotatedStyledText styledText = new AnnotatedStyledText(textNode.text(), currentFontSize, currentFont,
                            Color.black, 0, Collections.singleton(underlineAnnotation));
                    paragraph.add(styledText);
                } else {
                    paragraph.addText(textNode.text(), currentFontSize, currentFont);
                }
            }

        } catch (IOException e) {
            exception = e;
        }
    }

    @Override
    public void tail(Node node, int depth) {
        try {
            if (node instanceof Element) {
                Element elementNode = (Element) node;

                switch (elementNode.normalName()) {
                    case "p":
                        paragraph.add(new NewLine(new FontDescriptor(currentFont, currentFontSize)));
                        break;

                    case "h6":
                        paragraph.add(new NewLine(new FontDescriptor(currentFont, currentFontSize)));
                        underline = false;
                        break;

                    case "a":
                        skipNextTextNode = false;
                        break;

                    case "ul":
                        Indent originalIndent = new Indent(
                                "",
                                0,
                                SpaceUnit.em,
                                currentFontSize,
                                currentFont,
                                Alignment.Right);
                        paragraph.add(new NewLine());
                        paragraph.add(originalIndent);
                        break;

                    case "strong":
                        currentFont = styles.getParagraphStyle().getFont();
                        currentFontSize = styles.getParagraphStyle().getFontSize();
                        break;

                    case "br":
                    case "li":
                    default:
                        break;
                }
            }
        } catch (IOException e) {
            exception = e;
        }
    }
}


